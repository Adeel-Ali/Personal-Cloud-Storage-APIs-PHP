<?php
/*
 * PersonalCloudStorageAPIsLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ) on 10/13/2016
 */

namespace PersonalCloudStorageAPIsLib\Controllers;

use PersonalCloudStorageAPIsLib\APIException;
use PersonalCloudStorageAPIsLib\APIHelper;
use PersonalCloudStorageAPIsLib\Configuration;
use PersonalCloudStorageAPIsLib\Models;
use PersonalCloudStorageAPIsLib\Exceptions;
use PersonalCloudStorageAPIsLib\Http\HttpRequest;
use PersonalCloudStorageAPIsLib\Http\HttpResponse;
use PersonalCloudStorageAPIsLib\Http\HttpMethod;
use PersonalCloudStorageAPIsLib\Http\HttpContext;
use Unirest\Request;

/**
 * @todo Add a general description for this controller.
 */
class FilesFoldersController extends BaseController {

    /**
     * @var FilesFoldersController The reference to *Singleton* instance of this class
     */
    private static $instance;
    
    /**
     * Returns the *Singleton* instance of this class.
     * @return FilesFoldersController The *Singleton* instance.
     */
    public static function getInstance()
    {
        if (null === static::$instance) {
            static::$instance = new static();
        }
        
        return static::$instance;
    }

    /**
     * Purges all the files and folder from a repository.
     * @param  string     $virtualfolder     Required parameter: Folder that represents various client types at the root level and contains their respective data.
     * @return void response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deletePurgeTrash (
                $virtualfolder) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/trash';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'virtualfolder' => $virtualfolder,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request]', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }
    }
        
    /**
     * Restores files or folders.
     * @param  Models\DeletedList $trashcanItems     Required parameter: Request object to restore files or folders from trash.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createRestoreTrash (
                $trashcanItems) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/fops/restore';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($trashcanItems));

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Path is invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new Exceptions\ErrorResponseException('[Not Found] Resource not found.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        return $response->body;
    }
        
    /**
     * Retrieve information on all file and folder content.
     * @param  string     $virtualfolder     Optional parameter: Folder that represents various client types at the root level and contains their respective data.
     * @param  string     $xHeaderETag       Optional parameter: Omit this header to request a full response.  To request only changes since a previous call to fullview, include this header as copied from your previous /fullview response.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getFullview (
                $virtualfolder = NULL,
                $xHeaderETag = NULL) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/fullview';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'virtualfolder' => $virtualfolder,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken),
            'X-Header-ETag'   => $xHeaderETag
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Query parameters missing or invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new Exceptions\ErrorResponseException('[Not Found] File was not found.', $_httpContext);
        }

        else if ($response->code == 412) {
            throw new Exceptions\ErrorResponseException('[Precondition Failed] An X-Header-ETag header was included in the request, and there are no changes to report.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\FullviewResponse());
    }
        
    /**
     * Retrieves file content.
     * @param  string     $path     Required parameter: The path to the file or folder.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getFiles (
                $path) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/files/{path}';

        //process optional query parameters
        APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'path' => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Query parameters missing or invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new Exceptions\ErrorResponseException('[Not Found] File was not found.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        return $response->body;
    }
        
    /**
     * Rename a file/folder.
     * @param  Models\FopsChangeRequest $fileRenameRequest     Required parameter: 'safe' and 'conflictsolve' are optional parameters in the request object to rename a file/folder.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function postRename (
                $fileRenameRequest) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/fops/rename';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'      => 'APIMATIC 2.0',
            'Accept'          => 'application/json',
            'content-type'    => 'application/json; charset=utf-8',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($fileRenameRequest));

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Query parameters missing or invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new Exceptions\ErrorResponseException('[Not Found] File was not found.', $_httpContext);
        }

        else if ($response->code == 409) {
            throw new Exceptions\ErrorResponseException('Conflict.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\MetadataResponse());
    }
        
    /**
     * Move a file or folder.
     * @param  Models\FopsChangeRequest $fileMoveRequest     Required parameter: 'safe' and 'conflictsolve' are optional parameters in the request object to move a file/folder.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function postMove (
                $fileMoveRequest) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/fops/move';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($fileMoveRequest));

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Query parameters missing or invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new Exceptions\ErrorResponseException('[Not Found] File was not found.', $_httpContext);
        }

        else if ($response->code == 409) {
            throw new Exceptions\ErrorResponseException('Conflict.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\MetadataResponse());
    }
        
    /**
     * Create a copy of a file/folder.
     * @param  Models\FopsCopyRequest $fileCopyRequest     Required parameter: 'safe', 'conflictsolve' and 'override' are optional parameters in the request object to copy a file/folder.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function postCopy (
                $fileCopyRequest) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/fops/copy';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($fileCopyRequest));

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Query parameters missing or invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new Exceptions\ErrorResponseException('[Not Found] File was not found.', $_httpContext);
        }

        else if ($response->code == 409) {
            throw new Exceptions\ErrorResponseException('Conflict.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\MetadataResponse());
    }
        
    /**
     * Delete a file/folder.
     * @param  string     $path      Required parameter: Full path of the file/folder to be deleted.
     * @param  bool       $purge     Optional parameter: If 'true', permanently deletes the file/folder.
     * @return void response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteDelete (
                $path,
                $purge = false) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/fops/delete';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path'  => $path,
            'purge' => (null != $purge) ? var_export($purge, true) : false,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Query parameters missing or invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new Exceptions\ErrorResponseException('[Not Found] File was not found.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }
    }
        
    /**
     * Create a folder.
     * @param  Models\FolderRequest $folder     Required parameter: 'override' is an optional parameter in the request object to create a folder.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function postCreatefolder (
                $folder) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/fops/createfolder';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($folder));

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Query parameters missing or invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new Exceptions\ErrorResponseException('[Not Found] Path was not found.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\FolderMetadata());
    }
        
    /**
     * Completes chunk file upload.
     * @param  string     $uploadid     Required parameter: Unique id to upload file binary content and to create the file. Uploadid is obtained via a call to the /fileupload/intent API (it is embedded in the URLs included in the response).
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function uploadFileCreate (
                $uploadid) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/commit/{uploadid}';

        //process optional query parameters
        APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'uploadid' => $uploadid,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Query parameters missing or invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\FileMetadata());
    }
        
    /**
     * Retrieves a list of deleted files and folders from a single user repository.
     * @param  string      $virtualfolder     Required parameter: Folder that represents various client types at the root level and contains their respective data.
     * @param  string      $sort              Optional parameter: Controls the sort order in which the response is returned. Uses the syntax: sort={field}+(asc|desc).
     * @param  integer     $start             Optional parameter: Starting point for partial responses, for folder requests. Default is 1.
     * @param  integer     $count             Optional parameter: Maximum items to include in a paginated response, for folder requests.  Required if start is specified.
     * @param  string      $filter            Optional parameter: Set to 'file' or 'folder', to include only those types of items in the response.
     * @param  bool        $deep              Optional parameter: Specifies whether the search should stop at the topmost deleted item in the tree (deep=false), or navigate into it and list all the deleted contents    (deep=true).
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function retrieveTrash (
                $virtualfolder,
                $sort = NULL,
                $start = NULL,
                $count = NULL,
                $filter = NULL,
                $deep = false) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/trash';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'virtualfolder' => $virtualfolder,
            'sort'          => $sort,
            'start'         => $start,
            'count'         => $count,
            'filter'        => $filter,
            'deep'          => (null != $deep) ? var_export($deep, true) : false,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Query parameters missing or invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new Exceptions\ErrorResponseException('[Not Found] Resource not found.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\TrashResponse());
    }
        
    /**
     * Search for files and folders.
     * @param  string      $query             Required parameter: Contains the text to be searched and supports a number of query fields that allow clients to restrict the search to particular parts of a file's or folder's metadata
     * @param  string      $virtualfolder     Optional parameter: Folder that represents various client types at the root level and contains their respective data.
     * @param  string      $sort              Optional parameter: Specify sort order for response. Syntax is :'{field}+{asc|desc}'.  Valid values for 'field' are: name, versionCreated, size, extension, album, artist, captureDate, compilation, contentType, creationDate, favorite, genre, height, modificationDate, priority, source, tags, title, timelineDate
     * @param  integer     $start             Optional parameter: Page number to return, for paginated responses. Default is 1.
     * @param  integer     $count             Optional parameter: Maximum items to include in a paginated response, for folder requests.  Required if start is specified.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getSearch (
                $query,
                $virtualfolder = NULL,
                $sort = NULL,
                $start = NULL,
                $count = NULL) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/search';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'query'         => $query,
            'virtualfolder' => $virtualfolder,
            'sort'          => $sort,
            'start'         => $start,
            'count'         => $count,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Query parameters missing or invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\SearchresultResponse());
    }
        
    /**
     * Retrieve thumbnails for a file.
     * @param  string      $contentToken      Required parameter: The file's content token (obtained from a call to /metadata or /fullview).
     * @param  string      $size              Required parameter: Thumbnail size: 'xs' (24x24), 's' (64x64), or 'm' (128x128). Either 'size' or 'th' and 'tw' are required.
     * @param  integer     $th                Required parameter: Thumbnail height (in pixels). Either 'size' or 'th' and 'tw' are required.
     * @param  integer     $tw                Required parameter: Thumbnail width (in pixels). Either 'size' or 'th' and 'tw' are required.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getThumbnails (
                $contentToken,
                $size,
                $th,
                $tw) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/thumbnails/{content-token}';

        //process optional query parameters
        APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'content-token' => $contentToken,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'size'          => $size,
            'th'            => $th,
            'tw'            => $tw,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Query parameters missing or invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new Exceptions\ErrorResponseException('[Not Found] File was not found.', $_httpContext);
        }

        else if ($response->code == 415) {
            throw new Exceptions\ErrorResponseException('[Unsupported Media Type] Thumbnails are not supported for this type of file.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        return $response->body;
    }
        
    /**
     * Get metadata for a file or folder in a user's repository.
     * @param  string      $path                Required parameter: The path to the file or folder.
     * @param  bool        $includeDeleted      Optional parameter: if true, response will include deleted files and folders. Default is false.
     * @param  string      $sort                Optional parameter: Specify sort order for response. Syntax is :'{field}+{asc|desc}'.  Valid values for 'field' are: name, versionCreated, size, extension, album, artist, captureDate, compilation, contentType, creationDate, favorite, genre, height, modificationDate, priority, source, tags, title, timelineDate
     * @param  integer     $start               Optional parameter: Starting point for partial responses, for folder requests. Default is 1.
     * @param  integer     $count               Optional parameter: Maximum items to include in a paginated response, for folder requests.  Required if start is specified.
     * @param  string      $filter              Optional parameter: Set to 'file' or 'folder', to include only those types of items in the response.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getMetadataPath (
                $path,
                $includeDeleted = false,
                $sort = NULL,
                $start = NULL,
                $count = NULL,
                $filter = NULL) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/metadata/{path}';

        //process optional query parameters
        APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'path'            => $path,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'include_deleted' => (null != $includeDeleted) ? var_export($includeDeleted, true) : false,
            'sort'            => $sort,
            'start'           => $start,
            'count'           => $count,
            'filter'          => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Query parameters missing or invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new Exceptions\ErrorResponseException('[Not Found] File was not found.', $_httpContext);
        }

        else if ($response->code == 410) {
            throw new Exceptions\ErrorResponseException('[Gone] File was removed.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\MetadataResponse());
    }
        
    /**
     * Get metadata for the root folder contents.
     * @param  bool        $includeDeleted      Optional parameter: if true, response will include deleted files and folders. Default is false.
     * @param  string      $sort                Optional parameter: Specify sort order for response. Syntax is :'{field}+{asc|desc}'.  Valid values for 'field' are: name, versionCreated, size, extension, album, artist, captureDate, compilation, contentType, creationDate, favorite, genre, height, modificationDate, priority, source, tags, title, timelineDate
     * @param  integer     $start               Optional parameter: Starting point for partial responses, for folder requests. Default is 1.
     * @param  integer     $count               Optional parameter: Maximum items to include in a paginated response, for folder requests.  Required if start is specified.
     * @param  string      $filter              Optional parameter: Set to 'file' or 'folder', to include only those types of items in the response.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getMetadata (
                $includeDeleted = false,
                $sort = NULL,
                $start = NULL,
                $count = NULL,
                $filter = NULL) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/metadata';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'include_deleted' => (null != $includeDeleted) ? var_export($includeDeleted, true) : false,
            'sort'            => $sort,
            'start'           => $start,
            'count'           => $count,
            'filter'          => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Query parameters missing or invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 404) {
            throw new Exceptions\ErrorResponseException('[Not Found] File was not found.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\MetadataResponse());
    }
        
    /**
     * Initiates a file upload intent request.
     * @param  string      $path         Required parameter: The path to the folder where file has to be uploaded.
     * @param  string      $name         Required parameter: Name of the file to be uploaded.
     * @param  integer     $size         Required parameter: Size of the file to be uploaded.
     * @param  string      $checksum     Required parameter: Checksum of the file/chunk.
     * @param  bool        $chunk        Optional parameter: Should be set to false, in case the file binary has to be uploaded with single request. Otherwise should be set to true when file binary has to be uploaded in multiple request.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getUploadFileIntent (
                $path,
                $name,
                $size,
                $checksum,
                $chunk = false) 
    {
        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/fileupload/intent';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path'     => $path,
            'name'     => $name,
            'size'     => $size,
            'checksum' => $checksum,
            'chunk'    => (null != $chunk) ? var_export($chunk, true) : false,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'Authorization' => sprintf('Bearer %1$s', Configuration::$oAuthAccessToken)
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);            
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        //call on-after Http callback
        if($this->getHttpCallBack() != null) {
            $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
            $_httpContext = new HttpContext($_httpRequest, $_httpResponse);
            
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);            
        }

        //Error handling using HTTP status codes
        if ($response->code == 400) {
            throw new Exceptions\ErrorResponseException('[Bad Request] Query parameters missing or invalid.', $_httpContext);
        }

        else if ($response->code == 401) {
            throw new Exceptions\ErrorResponseException('[Unauthorized] Bearer token is missing, expired, or invalid.', $_httpContext);
        }

        else if ($response->code == 413) {
            throw new Exceptions\ErrorResponseException('[Request Too Long] User quota exceeded.', $_httpContext);
        }

        else if ($response->code == 503) {
            throw new Exceptions\ErrorResponseException('[Service Unavailable] See response body for more detail.', $_httpContext);
        }

        else if (($response->code < 200) || ($response->code > 208)) { //[200,208] = HTTP OK
            throw new APIException("HTTP Response Not OK", $_httpContext);
        }

        $mapper = $this->getJsonMapper();

        return $mapper->map($response->body, new Models\Uploadurls());
    }
        

}